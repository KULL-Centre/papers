---
title: "ArrayIIIb analysis"
output: html_notebook
---
```{r}
options(digits=2, stringsAsFactors=FALSE)
```

This notebook is based on the raw, annotated data from a file called _RawIIIb_100mM_NaCl_anno.csv_. 

All fields should have non-negative intensity. In some annotations, negative values are assigned to outliers and these should be reassigned <NA> before running this script. The columns of the sector replica should be named _sec1_, _sec2_,...

```{r}
file = "RawIIIb_100mM_NaCl_anno.csv"
d = read.table(file, sep=";", header=T)
d$seq = as.character(d$seq)
sec_col = paste("sec",seq(12),sep="")
stopifnot(sum(d[,sec_col] < 0, na.rm=T) == 0)
stopifnot(all(sec_col %in% colnames(d)))
sprintf("Loaded data from %d fields in %d replica from %s", dim(d)[1], length(sec_col), file)
```

# Outliers
Remove sector-replica outliers one column at a time using median absolute deviation (MAD)

Assign median, median absolute deviation (MAD) and (re)-calculate the mean and standard deviation (SD). The MAD is calculated as 1.4826 * median(abs(X-median)) where the scale factor is approximate 50% normal density.
```{r}
d$median = apply(d[,sec_col], MARGIN=1, median, na.rm=T)
d$mad = apply(d[,sec_col], MARGIN=1, mad, na.rm=T)
d$mean = apply(d[,sec_col], MARGIN=1, mean, na.rm=T)
d$sd = apply(d[,sec_col], MARGIN=1, sd, na.rm=T)
```

Calculate a noise level as the standard deviation of all blank fields. If MAD is smaller than the noise level, use this instead
```{r}
noise = sd(unlist(d[which(d$w=="blank"),sec_col]), na.rm=T)
d$uncert = sapply(d$mad, max, noise)
sprintf("Replace MAD with noise level %.2f for %d fields",noise,sum(d$uncert-d$mad > 1e-6))
```

Perform a conservative outlier filtering of fields that are more than 2*3 times brighter than the median. Three MAD would correspond to 3 SD and we use twice this value because the background level is significant (to be removed later). Contaminations are only expected to give brighter fields so a warning is generated if small outliers are detected.
```{r}
n_rm = 0
for (col in sec_col) {
    mask = apply(d[,c('median','uncert',col)], MARGIN=1, function(a) { (a[3]-a[1])/a[2] > 6})
    neg_mask = apply(d[,c('median','uncert',col)], MARGIN=1, function(a) { (a[3]-a[1])/a[2] < -6})
    if (any(neg_mask,na.rm=T)) print(sprintf("WARNING: %s has %d small outliers not removed",col,sum(neg_mask,na.rm=T)))
    d[which(mask),col] = NA
    print(sprintf("Removed %3d outliers from column %s",sum(mask, na.rm=T),col))
    n_rm = n_rm+sum(mask, na.rm=T)
}
print(sprintf("Total %d outliers removed of %d (%.2f%%)",n_rm,nrow(d),n_rm/nrow(d)*100))
```

Re-calc means and standard deviations without outliers
```{r}
d$mean = apply(d[,sec_col], MARGIN=1, mean, na.rm=T)
d$sd = apply(d[,sec_col], MARGIN=1, sd, na.rm=T)
```

Std.dev. after outlier removal is in general close to MAD before outlier removal
```{r}
par(mar=c(5,6,2,2)+.2)
plot(d$mad, d$sd, pch=20,xlab="MAD before outlier removal", ylab="SD after outlier removal", cex.axis =1.6, cex.lab=1.8)
abline(0,1, lty=1)
abline(0,2, lty=2)
legend("bottomright",c("SD = MAD","SD = 2x MAD"), lty=c(1,2),cex=1.6)

```


# Normalization
Normalize each sector to the global mean using a scale factor
```{r}
norm_fact = mean(unlist(d[,sec_col]), na.rm=T) / apply(d[,sec_col], MARGIN=2, mean, na.rm=T)
d_sec_norm = d[,sec_col] * matrix(norm_fact, ncol=length(sec_col), nrow=dim(d)[1], byrow = T)
i_blank = which(d$w=="blank")
norm_bg = apply(d_sec_norm[i_blank,], MARGIN=2, mean, na.rm=T)
d_sec_norm = d_sec_norm - matrix(norm_bg, ncol=length(sec_col), nrow=dim(d)[1], byrow = T)
rbind(norm_fact,norm_bg)
```


In general this lowers the intensity variation of the same field in different sectors.
```{r}
norm_sd = apply(d_sec_norm, MARGIN=1, sd, na.rm=T)
par(mar=c(5,6,2,3)+.2)
plot(d$sd, norm_sd, pch=20, xlab="SD before normalization", ylab="SD after normalization", cex.axis =1.6, cex.lab=1.8)
abline(0,1)
abline(0,.5, lty=2)
legend("topleft", c("slope = 1","slope = 0.5"), lty=c(1,2), cex=1.6)
```
But keeps the mean over the 12 sectors constant before and after normalization
```{r}
norm_mean = apply(d_sec_norm, MARGIN=1, mean, na.rm=T)
par(mar=c(5,6,2,3)+.2)
plot(d$mean, norm_mean, pch=19, xlab="Mean before normalization", ylab="Mean after normalization", cex.axis =1.6, cex.lab=1.8)
abline(0,1)
legend("topleft", c("slope = 1"), lty=c(1,2), cex=1.6)
```

However, since the mean is dominated by the high-intensity (>1000) fields whereas the majority of fields get a higher variation. Thus, we subtract the background for individual sectors to compensate.

```{r}
breaks = seq(floor(min(unlist(c(d_sec_norm,d[,sec_col])),na.rm=T)), ceiling(max(unlist(c(d_sec_norm,d[,sec_col])),na.rm=T)), length.out = 1000)
color = 1
plot(0,0,col="white",xlim=c(min(breaks),1000), ylim=c(0,.005), xlab="Fluorescence", ylab="Density", main="Before normalization")
for (col in sec_col) {
  color = color+1
  h = hist(d[,col], breaks=breaks, plot=F)
  lines(h$mids, h$density, col=color)
}
legend("topright",sec_col,lty=1,col=seq(12), ncol=3)
color = 1
plot(0,0,col="white",xlim=c(min(breaks),1000), ylim=c(0,.005), xlab="Fluorescence", ylab="Density", main="After normalization")
for (col in sec_col) {
  h = hist(d_sec_norm[,color], breaks=breaks, plot=F)
  color = color+1
  lines(h$mids, h$density, col=color)
}
legend("topright",sec_col,lty=1,col=seq(12), ncol=3)
```

```{r}
par(mar=c(5,6,2,3)+.2)
plot(0,0,col="white", xlim=c(2,38), ylim=c(-200,600), ylab="Background fuorescence", xaxt="n", xlab="Sectors", cex.axis=1.6, cex.lab=1.8)
abline(h=c(mean(unlist(d[i_blank,sec_col]),na.rm=T),mean(unlist(d_sec_norm[i_blank,]),na.rm=T)), lty=2, col=c(2,3))
jitter = matrix(rnorm(12*length(i_blank),0,.1), nrow=length(i_blank), ncol=12, byrow=T)
points(matrix(seq(12), nrow=length(i_blank), ncol=12, byrow=T)*3+jitter, as.matrix(d[i_blank,sec_col]), cex=.3, col=2)
points(matrix(seq(12), nrow=length(i_blank), ncol=12, byrow=T)*3+1+jitter, as.matrix(d_sec_norm[i_blank,]), cex=.3, col=3)
legend("topleft", c("Before normalization","After normalization","Average"), col=c(2,3,1), pch=c(20,20,NA), lty=c(NA,NA,2), ncol=3, cex=1)

```

From here on, we only use the normalized values.
```{r}
d[,sec_col] = d_sec_norm
d$mean = apply(d[,sec_col], MARGIN=1, mean, na.rm=T) # Depending on normalization/bg, this may not be necessary
d$sd = apply(d[,sec_col], MARGIN=1, sd, na.rm=T)
```

And we replace all negative values in d caused by background subtraction with +1

```{r}
d[,sec_col][d[, sec_col] < 0] <- 1
d$mean = apply(d[,sec_col], MARGIN=1, mean, na.rm=T) # Recalc mean and SD
d$sd = apply(d[,sec_col], MARGIN=1, sd, na.rm=T)
```


# Charge dependency

Charged peptides may result in unspecific binding and if this effect is dominant, the level of fluorescence will correlate with the charge of the peptide. We only see this for low fluorescence < 2^8 = 256 and trust that higher fluorecence is not due to unspecific charge interactions. Interestingly, there's a similar tendency for negatively charged peptides which suggests a solubility related effect rather than a charge interaction.

```{r}
# Calculate the formal charge of each sequence
d$chg = sapply(d[,'seq'], function(s) {sl=strsplit(s, "")[[1]]; sum(sl %in% c('K','R')) - sum(sl %in% c('D','E'))})

#tiff("charge.tiff", width=9, height=6, units="cm", res=500, compression="lzw", pointsize=6.5)
plot(d$chg, rep(1,length(d$chg)), col="white", ylim=c(0,40000), xlim=c(-5,5), xlab="Peptide formal charge", ylab="Mean fluorescence", cex.axis =1.8, cex.lab=2)
what2plot = c("long","short","short_shift1","short_shift2","blank","flag","link")
namesl = c("long", "short", "shortL","shortR", "neg", "linker", "FLAG", "blank")
coll =      c(     4,            7 ,            5 ,    2 ,     "gray45" ,    6 ,    1 , 8) 
pchl = c(rep(16,length(what2plot)))
for (wi in seq_along(what2plot)) {
  di = which(d$w == what2plot[wi] & d$mean > 1)
  points(d[di,"chg"]+rnorm(length(di), mean=0, sd=.1), d[di,"mean"], col=coll[wi], pch=pchl[wi], cex=.8)
}
legend("topright", namesl, pch=pchl, col=coll, ncol=2, cex=1.6)
#dev.off()
```

# Format dependency
We next want to compare how different formats perform in term of fluorescence dynamic range; we also look for specificity towards s10 peptides compared to controls

```{r}
#first remove all designs
designs <- c("extra","frag","short_vrich","rosetta")
d_clean <- subset(d, !(w %in% designs) & l_len != "4")

#remove all double and triple substitutions, since they were only done on the long and short formats
d_clean_single <- d_clean[!(d_clean$d %in% c(2,3)),]

library(ggplot2)
w <- factor(d_clean_single$w)

p <- ggplot(d_clean_single, aes(x=w, y=mean))
#tiff("fluorescence vs s10 length format.tiff", units="in", width=11, height=15, res=500)
p +  geom_jitter(position=position_jitter(0.3)) +
     geom_hline(yintercept=742, linetype="dashed", color = "black", size=0.5) + # mean s10 long
     xlab("\nPeptide format") + 
     ylab("Mean fluorescence\n") + ylim(0,8500) +
     theme(axis.text.x = element_text(angle = 90)) +
     scale_x_discrete(limits=c("long","short","short_shift1", "short_shift2", "neg_control", "link", "flag", "blank"),
                      labels = c("long","short","shortL", "shortR", "neg", "linker", "FLAG", "blank")) + 
     stat_summary(fun=median, geom="point", shape=20, size=2, color ="red") +
     theme_classic() +
     theme(legend.position = "none", axis.title = element_text(size=28), 
           axis.text.y = element_text(size=22), 
           axis.text.x = element_text(angle = 90, size = 28))

#dev.off()
```



# Functions for everything-else-equal (EEE) plots

We found it generally useful to plot correlations of many data points where only a single feature differes and every thing else is the same. Features could be the linker, the peptide length, a specific substitution, etc. The computational task of generating this list of data points where only a single feature differs is solved here for later usage.

```{r}
etee_match = function(ete, var) {
    # function to identify pairs of list indices with var=1, var=2 and everything else equal (etee)
    # var should be either 1 (x-axis), 2 (y-axis) or 0 (disregard) and ete the rest of the sequence to be matched
    # make a hash of ete ids
    u_ete = unique(ete)
    map = seq(u_ete)
    names(map) = u_ete
    # identify indices with var=1 and var=2
    i1 = which(var==1)
    i2 = which(var==2)
    # sort the indices according to ete id
    l1 = list()
    l2 = list()
    for (i in i1) { ete_i = map[ete[i]];  if (length(l1) < ete_i) l1[[ete_i]] = c(i) else l1[[ete_i]] = append(l1[[ete_i]], i) }
    for (i in i2) { ete_i = map[ete[i]];  if (length(l2) < ete_i) l2[[ete_i]] = c(i) else l2[[ete_i]] = append(l2[[ete_i]], i) }
    # highest common ete id observed
    ll = min(length(l1),length(l2))
    # make a matrix with a pair of indices per row
    ml = sum(sapply(l1[1:ll],length)*sapply(l2[1:ll],length))
    m = matrix(NA, nrow=ml, ncol=2)
    i = 0
    for (li in seq(ll)) for (i1 in l1[[li]]) for (i2 in l2[[li]]) { i=i+1; m[i,] = c(i1,i2) }
    return(m)
}

plot_etee = function(data, lim_max=10, ...) {
    plot(data$F1, data$F2, col="lightgray", xlim=c(5.5,lim_max), ylim=c(5.5,lim_max), pch=20, ...)
    abline(0,1)
    datai = which(data$li1=="GSGSGSG")
    points(data[datai,'F1'], data[datai,'F2'], pch=20, cex=.8, col=2)
    datai = which(data$li1=="GKGSKSG")
    points(data[datai,'F1'], data[datai,'F2'], pch=20, cex=.8, col=3)
    datai = which(data$li1=="GEGSESG")
    points(data[datai,'F1'], data[datai,'F2'], pch=20, cex=.8, col=4)
    datai = which(data$li1=="none")
    points(data[datai,'F1'], data[datai,'F2'], pch=20, cex=.8, col=8)
    legend("bottomright",c("Neutral","Positive","Negative","None","slope = 1"), pch=c(20,20,20,20,NA), lty=c(NA,NA,NA,NA,1), col=c(2,3,4,8,1))
}
```

# Short vs long peptide

The difference between the long and the short peptide context may be plotted as the intensity of the short peptides versus the the same sequence in the long context. The long context is in general brighter than the short 

```{r}
  sdi = which(d$w=="short"  & d$link != "GSGS")
  ldi = which(d$w=="long")
  i = which(substr(d[ldi,'seq'],1,3)=="LPD" & substr(d[ldi,'seq'],15,18)=="KDPN")
  ldi = ldi[i]
  #                1      2      3         4         5         6
  linker_str = c("GS","GSGS","GKGK","GSGSGSG","GKGSKSG","GEGSESG")
  # from long remove LPD-short11-KDPN and add linker if present
  # from shoart only keep the to first linker res to match neutral and none linker
  ete = c(substr(d[sdi,'seq'],1,13), paste(substr(d[ldi,'seq'],4,14),substr(d[ldi,'seq'],19,nchar(d[ldi,'seq'])), sep=""))
  v = c(rep(1,length(sdi)),rep(2,length(ldi)))
  di = c(sdi,ldi)
  i = etee_match(ete, v)
  i1 = di[i[,1]]
  i2 = di[i[,2]]
  # dd = data.frame(seq1=d[i1,'seq'], seq2=d[i2,'seq'], F1=d[i1,'mean'], F2=d[i2,'mean'], li1=droplevels(d[i1,'link']), li2=droplevels(d[i2,'link']), d1=d[i1,'d'], d2=d[i2,'d'])
  dd = data.frame(seq1=d[i1,'seq'], seq2=d[i2,'seq'], F1=d[i1,'mean'], F2=d[i2,'mean'], li1=d[i1,'link'], li2=d[i2,'link'], d1=d[i1,'d'], d2=d[i2,'d'])
  stopifnot(all((dd$li1=="none") == (dd$li2=="none")))
  
  #quartz(height=6, width=6)
  par(mar=c(6,7,3,2)+.2)
plot(dd$F1, dd$F2, pch=20, 
     xlab="", 
     ylab="long format, all substitution variants
     Mean fluorescence", 
     xlim=c(0,15000), ylim=c(0,25000), cex.axis =1.6, cex.lab=1.8)
mtext(text = "Mean fluorescence
      short format, all substitution variants",
      side = 1, #side 2 = left
      line = 4.8,
      cex=1.8)
abline(0,1)
coll=c(2,4)
points(dd$F1, dd$F2, pch=19, cex=.6, col=coll[dd$li1])
#ddi = which(substr(dd$seq1,10,10)=="R")
#points(dd['F1'], dd['F2'], pch=20, cex=.3, col=4)
legend("bottomright",c("Neutral linker","No linker","slope = 1"), 
       pch=c(20,20,NA), lty=c(NA,NA,1), col=c(2,4,1), cex=1.6)

#quartz.save("short_vs_long.png",type="png")

```

# Linker effect

The short peptides are tested with with 3 different linkers and without linker. A charged linker seems to have a small but positive effect on intensity and the absence of linker a varying effect.

```{r}
# Select peptides to consider
# extra is missing the negative linker, vrich gives weird lines from many replica, and the shifted are not that fun...
wl = c("short","short_shift1","short_shift2","short_vrich","frag","rosetta","neg_control","link")
w_mask = d$w %in% wl
# Data set 1
di = which(w_mask & d$link %in% c("GSGSGSG","GKGSKSG"))
i = etee_match(substr(d[di,'seq'],1,11), (d[di,'link']=="GSGSGSG")+1 )
# i = etee_match(substr(d[di,'seq'],1,11), as.integer(droplevels(d[di,'link'])))
i1 = di[i[,1]]
i2 = di[i[,2]]
dd1 = data.frame(seq1=d[i1,'seq'], seq2=d[i2,'seq'], w=d[i1,'w'], F1=d[i1,'mean'], F2=d[i2,'mean'], li1=d[i1,'link'], li2=d[i2,'link'], d1=d[i1,'d'], d2=d[i2,'d'])
# Data set 2
di = which(w_mask & d$link %in% c("GSGSGSG","GEGSESG"))
i = etee_match(substr(d[di,'seq'],1,11), (d[di,'link']=="GSGSGSG")+1 )
# i = etee_match(substr(d[di,'seq'],1,11), as.integer(droplevels(d[di,'link'])))
i1 = di[i[,1]]
i2 = di[i[,2]]
dd2 = data.frame(seq1=d[i1,'seq'], seq2=d[i2,'seq'], w=d[i1,'w'], F1=d[i1,'mean'], F2=d[i2,'mean'], li1=d[i1,'link'], li2=d[i2,'link'], d1=d[i1,'d'], d2=d[i2,'d'])
# Data set 3
di = which(w_mask & d$link %in% c("GSGSGSG","none"))
i = etee_match(substr(d[di,'seq'],1,11), (d[di,'link']=="GSGSGSG")+1 )
# i = etee_match(substr(d[di,'seq'],1,11), as.integer(droplevels(d[di,'link'])))
i1 = di[i[,1]]
i2 = di[i[,2]]
dd3 = data.frame(seq1=d[i1,'seq'], seq2=d[i2,'seq'], w=d[i1,'w'], F1=d[i1,'mean'], F2=d[i2,'mean'], li1=d[i1,'link'], li2=d[i2,'link'], d1=d[i1,'d'], d2=d[i2,'d'])
# Interestingly, these correlations are exactly the same for all wash images!

coll = c(1,seq(2,length(wl)))
names(coll) = wl
  par(mar=c(7,7,3,2)+.2)
  plot(dd1$F2, dd1$F1, pch=20, 
       xlab="", 
       ylab="short, positive linker, all variants
       Mean fluorescence",
       cex.axis =1.6, cex.lab=1.8)
  mtext(text = "Mean fluorescence
        short, neutral linker, all variants",
        side = 1, #side 2 = left
        line = 5,
        cex=1.8)
  abline(0,1)
  #for (w in wl) {i=which(dd1$w==w); points(dd1[i,'F2'], dd1[i,'F1'], pch=20, cex=.4, col=coll[w])}
  legend("topleft", c("slope = 1"), lty=1,cex=1.6)
  #legend("bottomright", names(coll), pch=20, col=coll, cex=.9, bg="white", ncol=2)
  plot(dd2$F2, dd2$F1, pch=20, 
       xlab="", 
       ylab="short, negative linker, all variants
       Mean fluorescence",
       cex.axis =1.6, cex.lab=1.8)
  mtext(text = "Mean fluorescence
        short, neutral linker, all variants",
        side = 1, #side 2 = left
        line = 5,
        cex=1.8)
  abline(0,1)
  #for (w in wl) {i=which(dd2$w==w); points(dd2[i,'F2'], dd2[i,'F1'], pch=20, cex=.4, col=coll[w])}
  plot(dd3$F2, dd3$F1, pch=20, 
       xlab="", 
       ylab="short, no linker, all variants
       Mean fluorescence",
       cex.axis =1.6, cex.lab=1.8)
  mtext(text = "Mean fluorescence
        short, neutral linker, all variants",
        side = 1, #side 2 = left
        line = 5,
        cex=1.8)
  abline(0,1)
# for (w in wl) {i=which(dd3$w==w); points(dd3[i,'F2'], dd3[i,'F1'], pch=20, cex=.4, col=coll[w])}
# plot(dd1$F2, dd1$F1, pch=20, xlab="Neutral linker fluorescence", ylab="Positive linker fluorescence", main="Positive linker, low fluorescence", xlim=c(0,1500), ylim=c(0,1500))
# abline(0,1)
# for (w in wl) {i=which(dd1$w==w); points(dd1[i,'F2'], dd1[i,'F1'], pch=20, cex=.4, col=coll[w])}
# legend("topleft", c("slope = 1"), lty=1)
# legend("bottomright", names(coll), pch=20, col=coll, cex=.9, bg="white", ncol=2)
# plot(dd2$F2, dd2$F1, pch=20, xlab="Neutral linker fluorescence", ylab="Negative linker fluorescence", main="Negative linker, low fluorescence", xlim=c(0,1500), ylim=c(0,1500))
# abline(0,1)
# for (w in wl) {i=which(dd2$w==w); points(dd2[i,'F2'], dd2[i,'F1'], pch=20, cex=.4, col=coll[w])}
# plot(dd3$F2, dd3$F1, pch=20, xlab="Neutral linker fluorescence", ylab="No linker fluorescence", main="No linker, low fluorescence", xlim=c(0,1500), ylim=c(0,1500))
# abline(0,1)
# for (w in wl) {i=which(dd3$w==w); points(dd3[i,'F2'], dd3[i,'F1'], pch=20, cex=.4, col=coll[w])}

```

The long peptide is tested with a short, neutral linker and wthout a linker. Again, the absence of a linker seems to have a varying effect. In contrast to the short peptide, the long have significantly higher intensity without linker.

```{r}
# Long
di = which(d$w=="long")
i = etee_match(substr(d[di,'seq'],1,18), (d[di,'link']=="GS")+1 )
i1 = di[i[,1]]
i2 = di[i[,2]]
dd1 = data.frame(seq1=d[i1,'seq'], seq2=d[i2,'seq'], w=d[i1,'w'], F1=d[i1,'mean'], F2=d[i2,'mean'], li1=d[i1,'link'], li2=d[i2,'link'], d1=d[i1,'d'], d2=d[i2,'d'])
dd1$nH = sapply(dd1$seq1,function(s){l=strsplit(as.character(s),"")[[1]]; sum(l=="H")})
#quartz(height=6, width=6)
par(mar=c(7,7,3,2)+.2)
plot(dd1$F2, dd1$F1, pch=20, 
       xlab="", 
       ylab="long, no linker, all variants
  Mean fluorescence",
       cex.axis =1.6, cex.lab=1.8, xlim=c(0,35000), ylim=c(0,35000))
  mtext(text = "Mean fluorescence
  long, neutral linker, all variants",
        side = 1, #side 2 = left
        line = 5,
        cex=1.8)
abline(0,1)
#points(dd1$F2, dd1$F1, pch=20, cex=0.6, col=dd1$nH+1)
legend("bottomright", c("slope=1"), pch=NA, lty=1, col=1,cex=1.6)
```

# Heatmap single substitutions in one context

```{r}
d4 <- d[,c(2,3)]

first_position_in_wt <- 195
substituting_aa <- "RHKDECGPAVILMFYWSTNQ"
#######################################################################WT
wt_sequence <- "LPDNHYLSTQTVLSKDPN"
# Extract sequence of the WT 
wtseq <- vector()
for(i in 1:nchar(as.character(wt_sequence))) {
  wtseq[i]<-substr(wt_sequence,i,i) 
}
# Subset dataframe to only include peptides of the same length as the wt
sameLengthAsWT <-subset(d4,nchar(as.character(d4$seq),type="chars") == nchar(as.character(wt_sequence),type="chars"))
# Create vector with single amino acid substitutions only
Boolean_string <- c()
for(m in 1:length(sameLengthAsWT$seq)) {  #for all peptides of same length as wt
  v <- unlist(strsplit(as.character(wt_sequence),character())) #wt sequence
  w <- unlist(strsplit(as.character(sameLengthAsWT$seq[m]),character()))  #sequence of the other peptides
  if(sum(v==w) == nchar(as.character(wt_sequence))-1) {  #if wt sequence and sequence of other peptide has all but one amino acids in common...
    Boolean_string[m]<-m        #returning a vector of the positions in sameLengthAsWT$Peptide meeting the criteria
  }
}
Boolean_string<-na.omit(Boolean_string)
SingleSubs<-sameLengthAsWT$seq[Boolean_string]
# Creating a data frame with wt amino acids as column names and turning it into a vector
new_list <- list()
for(j in first_position_in_wt:(first_position_in_wt + nchar(as.character(wt_sequence)) - 1)) {
  new_list[[paste0(wtseq[j-first_position_in_wt+1],j,sep="")]] = NA
}
wt_amino_acids<-as.data.frame(new_list)
wt_amino_acids<-as.vector(names(wt_amino_acids))
# Vector with substituting amino acids
substituting_amino_acids<-unlist(strsplit(substituting_aa,character()))
# Create empty matrix with the substitution table format
no_substitutions_mean <- d4[d4$seq==wt_sequence,"mean"]
substitution_table <- matrix(data=c(no_substitutions_mean), nrow = length(substituting_amino_acids),ncol = length(wtseq))
colnames(substitution_table) <- wt_amino_acids
rownames(substitution_table) <- substituting_amino_acids
# Fill table with mean values
for(i in 1:length(SingleSubs)) {
  for(j in 1:nchar(wt_sequence)) {
    if(substr(SingleSubs[i],j,j) != wtseq[j]) {
      substitution_table[substr(SingleSubs[i],j,j),j] <- d4[d4$seq==SingleSubs[i],"mean"]
    }
  }
}
# Rearrange substitution_table for heatmap
st <- data.frame(substitution_table)
library(tidyr)
st_gathered <- gather(st)
names(st_gathered) <- c("Position", "Fluorescence") 
# Keep only the position number without the WT residue
st_gathered$Position <- substring(st_gathered$Position, 2)
# Add the substituting AA and and rearrange the DF
st_gathered$Substitution <- substituting_amino_acids
st_gathered_WT <- st_gathered

# Plot

  WT <- st_gathered_WT[st_gathered_WT$Position=="195" & st_gathered_WT$Substitution=="L", 2]
  WT <- log2(WT) 

  #Context <- factor("WT") 
  Position <- factor(st_gathered_WT$Position, levels = c("195", "196", "197", "198", "199", "200", "201", "202", "203", "204", "205", "206", "207", "208", "209", "210", "211", "212"))
  Fluorescence <- st_gathered_WT$Fluorescence
 
  library(ggplot2)
   context.heatmap <- ggplot(data = st_gathered_WT, mapping = aes(x = Position,
                                                                  y = Substitution,
                                                                  fill =  log2(Fluorescence))) +
    geom_tile(color = "white") +
    #geom_rect() +
    xlab(label = "Position") +
    ylab(label = "Substituting residue") +
    #facet_grid(~ Position, switch = "x", scales = "free_x", space = "free_x")
    scale_y_discrete(position = "right", limits = c("Q", "N", "T", "S", "W", "Y", "F", "M", "L", "I", "V", "A", "P", "G", "C", "E", "D", "K", "H","R")) +
    scale_x_discrete(labels=c("L195", "P196", "D197", "N198", "H199", "Y200", "L201", "S202", "T203", "Q204", "T205", "V206", "L207", "S208", "K209", "D210", "P211", "N212")) +
    scale_fill_gradient2(low="blue", high="red", mid="yellow",
                      midpoint = WT, limits = c(min(log2(Fluorescence)),max(log2(Fluorescence)))) +
    #scale_fill_gradientn(colours = color.palette, breaks = col_breaks) +
    theme(axis.text.x = element_text(angle = 90, size = 14),
          axis.text.y = element_text(size = 14),
          axis.title = element_text(size = 16),
          legend.position="bottom", legend.text = element_text(size = 13), legend.title = element_text(size = 16))
  
  context.heatmap 

```

### Effect of context (double and triple substitutions)

First we need to get the fluorescence data together for all the scans in the WT, H199Y, T203Y, T203I, L207V, L207R and H199Y/T203Y contexts. We work with the long format, but the other formats can also be tested by changing the name of the "wt_sequence"

```{r}

d4 <- d[,c(2,3)]
#The loop didn't work out
#wt_sequence <- c("LPDNHYLSTQTVLSKDPN", "LPDNYYLSTQTVLSKDPN", "LPDNHYLSYQTVLSKDPN","LPDNHYLSIQTVLSKDPN","LPDNHYLSTQTVVSKDPN","LPDNHYLSTQTVRSKDPN","LPDNYYLSYQTVLSKDPN")
#context <- c("WT","H199Y","T203Y","T203I","L207V","L207R","H199Y/T203Y")

first_position_in_wt <- 195
substituting_aa <- "RHKDECGPAVILMFYWSTNQ"
#######################################################################WT
wt_sequence <- "LPDNHYLSTQTVLSKDPN"
context <- "WT"
# Extract sequence of the WT 
wtseq <- vector()
for(i in 1:nchar(as.character(wt_sequence))) {
  wtseq[i]<-substr(wt_sequence,i,i) 
}
# Subset dataframe to only include peptides of the same length as the wt
sameLengthAsWT <-subset(d4,nchar(as.character(d4$seq),type="chars") == nchar(as.character(wt_sequence),type="chars"))
                        
# Create vector with single amino acid substitutions only
Boolean_string <- c()
for(m in 1:length(sameLengthAsWT$seq)) {  #for all peptides of same length as wt
  v <- unlist(strsplit(as.character(wt_sequence),character())) #wt sequence
  w <- unlist(strsplit(as.character(sameLengthAsWT$seq[m]),character()))  #sequence of the other peptides
  if(sum(v==w) == nchar(as.character(wt_sequence))-1) {  #if wt sequence and sequence of other peptide has all but one amino acids in common...
    Boolean_string[m]<-m        #returning a vector of the positions in sameLengthAsWT$Peptide meeting the criteria
  }
}
Boolean_string<-na.omit(Boolean_string)
SingleSubsW<-sameLengthAsWT$seq[Boolean_string]
# Creating a data frame with wt amino acids as column names and turning it into a vector
new_list <- list()
for(j in first_position_in_wt:(first_position_in_wt + nchar(as.character(wt_sequence)) - 1)) {
  new_list[[paste0(wtseq[j-first_position_in_wt+1],j,sep="")]] = NA
}
wt_amino_acids<-as.data.frame(new_list)
wt_amino_acids<-names(wt_amino_acids)
# Vector with substituting amino acids
substituting_amino_acids<-unlist(strsplit(substituting_aa,character()))
# Create empty matrix with the substitution table format
no_substitutions_mean <- d4[d4$seq==wt_sequence,"mean"]
substitution_table <- matrix(data=c(no_substitutions_mean), nrow = length(substituting_amino_acids),ncol = length(wtseq))
colnames(substitution_table) <- wt_amino_acids
rownames(substitution_table) <- substituting_amino_acids
# Fill table with mean values
for(i in 1:length(SingleSubsW)) {
  for(j in 1:nchar(wt_sequence)) {
    if(substr(SingleSubsW[i],j,j) != wtseq[j]) {
      substitution_table[substr(SingleSubsW[i],j,j),j] <- d4[d4$seq==SingleSubsW[i],"mean"]
    }
  }
}
# Rearrange substitution_table for heatmap
st <- data.frame(substitution_table)
library(tidyr)
st_gathered <- gather(st)
names(st_gathered) <- c("Position", "Fluorescence") 
# Keep only the position number without the WT residue
st_gathered$Position <- substring(st_gathered$Position, 2)
# Add the substituting AA and context and rearrange the DF
st_gathered$Substitution <- substituting_amino_acids
st_gathered$Context <- context
st_gathered_WT <- st_gathered[,c(1,3,2,4)]


#######################################################################H199Y
wt_sequence <- "LPDNYYLSTQTVLSKDPN"
context <- "H199Y"
# Extract sequence of the WT 
wtseq <- vector()
for(i in 1:nchar(as.character(wt_sequence))) {
  wtseq[i]<-substr(wt_sequence,i,i) 
}
# Subset dataframe to only include peptides of the same length as the wt
sameLengthAsWT <-subset(d4,nchar(as.character(d4$seq),type="chars") == nchar(as.character(wt_sequence),type="chars"))
# Create vector with single amino acid substitutions only
Boolean_string <- c()
for(m in 1:length(sameLengthAsWT$seq)) {  #for all peptides of same length as wt
  v <- unlist(strsplit(as.character(wt_sequence),character())) #wt sequence
  w <- unlist(strsplit(as.character(sameLengthAsWT$seq[m]),character()))  #sequence of the other peptides
  if(sum(v==w) == nchar(as.character(wt_sequence))-1) {  #if wt sequence and sequence of other peptide has all but one amino acids in common...
    Boolean_string[m]<-m        #returning a vector of the positions in sameLengthAsWT$Peptide meeting the criteria
  }
}
Boolean_string<-na.omit(Boolean_string)
SingleSubsh<-sameLengthAsWT$seq[Boolean_string]
# Creating a data frame with wt amino acids as column names and turning it into a vector
new_list <- list()
for(j in first_position_in_wt:(first_position_in_wt + nchar(as.character(wt_sequence)) - 1)) {
  new_list[[paste0(wtseq[j-first_position_in_wt+1],j,sep="")]] = NA
}
wt_amino_acids<-as.data.frame(new_list)
wt_amino_acids<-names(wt_amino_acids)
# Vector with substituting amino acids
substituting_amino_acids<-unlist(strsplit(substituting_aa,character()))
# Create empty matrix with the substitution table format
no_substitutions_mean <- d4[d4$seq==wt_sequence,"mean"]
substitution_table <- matrix(data=c(no_substitutions_mean), nrow = length(substituting_amino_acids),ncol = length(wtseq))
colnames(substitution_table) <- wt_amino_acids
rownames(substitution_table) <- substituting_amino_acids
# Fill table with mean values
for(i in 1:length(SingleSubsh)) {
  for(j in 1:nchar(wt_sequence)) {
    if(substr(SingleSubsh[i],j,j) != wtseq[j]) {
      substitution_table[substr(SingleSubsh[i],j,j),j] <- d4[d4$seq==SingleSubsh[i],"mean"]
    }
  }
}
# Rearrange substitution_table for heatmap
st <- data.frame(substitution_table)
library(tidyr)
st_gathered <- gather(st)
names(st_gathered) <- c("Position", "Fluorescence") 
# Keep only the position number without the WT residue
st_gathered$Position <- substring(st_gathered$Position, 2)
# Add the substituting AA and context and rearrange the DF
st_gathered$Substitution <- substituting_amino_acids
st_gathered$Context <- context
st_gathered_H199Y <- st_gathered[,c(1,3,2,4)]

#######################################################################T203Y
wt_sequence <- "LPDNHYLSYQTVLSKDPN"
context <- "T203Y"
# Extract sequence of the WT 
wtseq <- vector()
for(i in 1:nchar(as.character(wt_sequence))) {
  wtseq[i]<-substr(wt_sequence,i,i) 
}
# Subset dataframe to only include peptides of the same length as the wt
sameLengthAsWT <-subset(d4,nchar(as.character(d4$seq),type="chars") == nchar(as.character(wt_sequence),type="chars"))
# Create vector with single amino acid substitutions only
Boolean_string <- c()
for(m in 1:length(sameLengthAsWT$seq)) {  #for all peptides of same length as wt
  v <- unlist(strsplit(as.character(wt_sequence),character())) #wt sequence
  w <- unlist(strsplit(as.character(sameLengthAsWT$seq[m]),character()))  #sequence of the other peptides
  if(sum(v==w) == nchar(as.character(wt_sequence))-1) {  #if wt sequence and sequence of other peptide has all but one amino acids in common...
    Boolean_string[m]<-m        #returning a vector of the positions in sameLengthAsWT$Peptide meeting the criteria
  }
}
Boolean_string<-na.omit(Boolean_string)
SingleSubsty<-sameLengthAsWT$seq[Boolean_string]
# Creating a data frame with wt amino acids as column names and turning it into a vector
new_list <- list()
for(j in first_position_in_wt:(first_position_in_wt + nchar(as.character(wt_sequence)) - 1)) {
  new_list[[paste0(wtseq[j-first_position_in_wt+1],j,sep="")]] = NA
}
wt_amino_acids<-as.data.frame(new_list)
wt_amino_acids<-names(wt_amino_acids)
# Vector with substituting amino acids
substituting_amino_acids<-unlist(strsplit(substituting_aa,character()))
# Create empty matrix with the substitution table format
no_substitutions_mean <- d4[d4$seq==wt_sequence,"mean"]
substitution_table <- matrix(data=c(no_substitutions_mean), nrow = length(substituting_amino_acids),ncol = length(wtseq))
colnames(substitution_table) <- wt_amino_acids
rownames(substitution_table) <- substituting_amino_acids
# Fill table with mean values
for(i in 1:length(SingleSubsty)) {
  for(j in 1:nchar(wt_sequence)) {
    if(substr(SingleSubsty[i],j,j) != wtseq[j]) {
      substitution_table[substr(SingleSubsty[i],j,j),j] <- d4[d4$seq==SingleSubsty[i],"mean"]
    }
  }
}
# Rearrange substitution_table for heatmap
st <- data.frame(substitution_table)
library(tidyr)
st_gathered <- gather(st)
names(st_gathered) <- c("Position", "Fluorescence") 
# Keep only the position number without the WT residue
st_gathered$Position <- substring(st_gathered$Position, 2)
# Add the substituting AA and context and rearrange the DF
st_gathered$Substitution <- substituting_amino_acids
st_gathered$Context <- context
st_gathered_T203Y <- st_gathered[,c(1,3,2,4)]

#######################################################################T203I
wt_sequence <- "LPDNHYLSIQTVLSKDPN"
context <- "T203I"
# Extract sequence of the WT 
wtseq <- vector()
for(i in 1:nchar(as.character(wt_sequence))) {
  wtseq[i]<-substr(wt_sequence,i,i) 
}
# Subset dataframe to only include peptides of the same length as the wt
sameLengthAsWT <-subset(d4,nchar(as.character(d4$seq),type="chars") == nchar(as.character(wt_sequence),type="chars"))
# Create vector with single amino acid substitutions only
Boolean_string <- c()
for(m in 1:length(sameLengthAsWT$seq)) {  #for all peptides of same length as wt
  v <- unlist(strsplit(as.character(wt_sequence),character())) #wt sequence
  w <- unlist(strsplit(as.character(sameLengthAsWT$seq[m]),character()))  #sequence of the other peptides
  if(sum(v==w) == nchar(as.character(wt_sequence))-1) {  #if wt sequence and sequence of other peptide has all but one amino acids in common...
    Boolean_string[m]<-m        #returning a vector of the positions in sameLengthAsWT$Peptide meeting the criteria
  }
}
Boolean_string<-na.omit(Boolean_string)
SingleSubsti<-sameLengthAsWT$seq[Boolean_string]
# Creating a data frame with wt amino acids as column names and turning it into a vector
new_list <- list()
for(j in first_position_in_wt:(first_position_in_wt + nchar(as.character(wt_sequence)) - 1)) {
  new_list[[paste0(wtseq[j-first_position_in_wt+1],j,sep="")]] = NA
}
wt_amino_acids<-as.data.frame(new_list)
wt_amino_acids<-names(wt_amino_acids)
# Vector with substituting amino acids
substituting_amino_acids<-unlist(strsplit(substituting_aa,character()))
# Create empty matrix with the substitution table format
no_substitutions_mean <- d4[d4$seq==wt_sequence,"mean"]
substitution_table <- matrix(data=c(no_substitutions_mean), nrow = length(substituting_amino_acids),ncol = length(wtseq))
colnames(substitution_table) <- wt_amino_acids
rownames(substitution_table) <- substituting_amino_acids
# Fill table with mean values
for(i in 1:length(SingleSubsti)) {
  for(j in 1:nchar(wt_sequence)) {
    if(substr(SingleSubsti[i],j,j) != wtseq[j]) {
      substitution_table[substr(SingleSubsti[i],j,j),j] <- d4[d4$seq==SingleSubsti[i],"mean"]
    }
  }
}
# Rearrange substitution_table for heatmap
st <- data.frame(substitution_table)
library(tidyr)
st_gathered <- gather(st)
names(st_gathered) <- c("Position", "Fluorescence") 
# Keep only the position number without the WT residue
st_gathered$Position <- substring(st_gathered$Position, 2)
# Add the substituting AA and context and rearrange the DF
st_gathered$Substitution <- substituting_amino_acids
st_gathered$Context <- context
st_gathered_T203I <- st_gathered[,c(1,3,2,4)]

#######################################################################L207V
wt_sequence <- "LPDNHYLSTQTVVSKDPN"
context <- "L207V"
# Extract sequence of the WT 
wtseq <- vector()
for(i in 1:nchar(as.character(wt_sequence))) {
  wtseq[i]<-substr(wt_sequence,i,i) 
}
# Subset dataframe to only include peptides of the same length as the wt
sameLengthAsWT <-subset(d4,nchar(as.character(d4$seq),type="chars") == nchar(as.character(wt_sequence),type="chars"))
# Create vector with single amino acid substitutions only
Boolean_string <- c()
for(m in 1:length(sameLengthAsWT$seq)) {  #for all peptides of same length as wt
  v <- unlist(strsplit(as.character(wt_sequence),character())) #wt sequence
  w <- unlist(strsplit(as.character(sameLengthAsWT$seq[m]),character()))  #sequence of the other peptides
  if(sum(v==w) == nchar(as.character(wt_sequence))-1) {  #if wt sequence and sequence of other peptide has all but one amino acids in common...
    Boolean_string[m]<-m        #returning a vector of the positions in sameLengthAsWT$Peptide meeting the criteria
  }
}
Boolean_string<-na.omit(Boolean_string)
SingleSubslv<-sameLengthAsWT$seq[Boolean_string]
# Creating a data frame with wt amino acids as column names and turning it into a vector
new_list <- list()
for(j in first_position_in_wt:(first_position_in_wt + nchar(as.character(wt_sequence)) - 1)) {
  new_list[[paste0(wtseq[j-first_position_in_wt+1],j,sep="")]] = NA
}
wt_amino_acids<-as.data.frame(new_list)
wt_amino_acids<-names(wt_amino_acids)
# Vector with substituting amino acids
substituting_amino_acids<-unlist(strsplit(substituting_aa,character()))
# Create empty matrix with the substitution table format
no_substitutions_mean <- d4[d4$seq==wt_sequence,"mean"]
substitution_table <- matrix(data=c(no_substitutions_mean), nrow = length(substituting_amino_acids),ncol = length(wtseq))
colnames(substitution_table) <- wt_amino_acids
rownames(substitution_table) <- substituting_amino_acids
# Fill table with mean values
for(i in 1:length(SingleSubslv)) {
  for(j in 1:nchar(wt_sequence)) {
    if(substr(SingleSubslv[i],j,j) != wtseq[j]) {
      substitution_table[substr(SingleSubslv[i],j,j),j] <- d4[d4$seq==SingleSubslv[i],"mean"]
    }
  }
}
# Rearrange substitution_table for heatmap
st <- data.frame(substitution_table)
library(tidyr)
st_gathered <- gather(st)
names(st_gathered) <- c("Position", "Fluorescence") 
# Keep only the position number without the WT residue
st_gathered$Position <- substring(st_gathered$Position, 2)
# Add the substituting AA and context and rearrange the DF
st_gathered$Substitution <- substituting_amino_acids
st_gathered$Context <- context
st_gathered_L207V <- st_gathered[,c(1,3,2,4)]

#######################################################################L207R
wt_sequence <- "LPDNHYLSTQTVRSKDPN"
context <- "L207R"
# Extract sequence of the WT 
wtseq <- vector()
for(i in 1:nchar(as.character(wt_sequence))) {
  wtseq[i]<-substr(wt_sequence,i,i) 
}
# Subset dataframe to only include peptides of the same length as the wt
sameLengthAsWT <-subset(d4,nchar(as.character(d4$seq),type="chars") == nchar(as.character(wt_sequence),type="chars"))
# Create vector with single amino acid substitutions only
Boolean_string <- c()
for(m in 1:length(sameLengthAsWT$seq)) {  #for all peptides of same length as wt
  v <- unlist(strsplit(as.character(wt_sequence),character())) #wt sequence
  w <- unlist(strsplit(as.character(sameLengthAsWT$seq[m]),character()))  #sequence of the other peptides
  if(sum(v==w) == nchar(as.character(wt_sequence))-1) {  #if wt sequence and sequence of other peptide has all but one amino acids in common...
    Boolean_string[m]<-m        #returning a vector of the positions in sameLengthAsWT$Peptide meeting the criteria
  }
}
Boolean_string<-na.omit(Boolean_string)
SingleSubslr<-sameLengthAsWT$seq[Boolean_string]
# Creating a data frame with wt amino acids as column names and turning it into a vector
new_list <- list()
for(j in first_position_in_wt:(first_position_in_wt + nchar(as.character(wt_sequence)) - 1)) {
  new_list[[paste0(wtseq[j-first_position_in_wt+1],j,sep="")]] = NA
}
wt_amino_acids<-as.data.frame(new_list)
wt_amino_acids<-names(wt_amino_acids)
# Vector with substituting amino acids
substituting_amino_acids<-unlist(strsplit(substituting_aa,character()))
# Create empty matrix with the substitution table format
no_substitutions_mean <- d4[d4$seq==wt_sequence,"mean"]
substitution_table <- matrix(data=c(no_substitutions_mean), nrow = length(substituting_amino_acids),ncol = length(wtseq))
colnames(substitution_table) <- wt_amino_acids
rownames(substitution_table) <- substituting_amino_acids
# Fill table with mean values
for(i in 1:length(SingleSubslr)) {
  for(j in 1:nchar(wt_sequence)) {
    if(substr(SingleSubslr[i],j,j) != wtseq[j]) {
      substitution_table[substr(SingleSubslr[i],j,j),j] <- d4[d4$seq==SingleSubslr[i],"mean"]
    }
  }
}
# Rearrange substitution_table for heatmap
st <- data.frame(substitution_table)
library(tidyr)
st_gathered <- gather(st)
names(st_gathered) <- c("Position", "Fluorescence") 
# Keep only the position number without the WT residue
st_gathered$Position <- substring(st_gathered$Position, 2)
# Add the substituting AA and context and rearrange the DF
st_gathered$Substitution <- substituting_amino_acids
st_gathered$Context <- context
st_gathered_L207R <- st_gathered[,c(1,3,2,4)]

#######################################################################H199Y/T203Y
wt_sequence <- "LPDNYYLSYQTVLSKDPN"
context <- "H199Y/T203Y"
# Extract sequence of the WT 
wtseq <- vector()
for(i in 1:nchar(as.character(wt_sequence))) {
  wtseq[i]<-substr(wt_sequence,i,i) 
}
# Subset dataframe to only include peptides of the same length as the wt
sameLengthAsWT <-subset(d4,nchar(as.character(d4$seq),type="chars") == nchar(as.character(wt_sequence),type="chars"))
# Create vector with single amino acid substitutions only
Boolean_string <- c()
for(m in 1:length(sameLengthAsWT$seq)) {  #for all peptides of same length as wt
  v <- unlist(strsplit(as.character(wt_sequence),character())) #wt sequence
  w <- unlist(strsplit(as.character(sameLengthAsWT$seq[m]),character()))  #sequence of the other peptides
  if(sum(v==w) == nchar(as.character(wt_sequence))-1) {  #if wt sequence and sequence of other peptide has all but one amino acids in common...
    Boolean_string[m]<-m        #returning a vector of the positions in sameLengthAsWT$Peptide meeting the criteria
  }
}
Boolean_string<-na.omit(Boolean_string)
SingleSubsht<-sameLengthAsWT$seq[Boolean_string]
# Creating a data frame with wt amino acids as column names and turning it into a vector
new_list <- list()
for(j in first_position_in_wt:(first_position_in_wt + nchar(as.character(wt_sequence)) - 1)) {
  new_list[[paste0(wtseq[j-first_position_in_wt+1],j,sep="")]] = NA
}
wt_amino_acids<-as.data.frame(new_list)
wt_amino_acids<-names(wt_amino_acids)
# Vector with substituting amino acids
substituting_amino_acids<-unlist(strsplit(substituting_aa,character()))
# Create empty matrix with the substitution table format
no_substitutions_mean <- d4[d4$seq==wt_sequence,"mean"]
substitution_table <- matrix(data=c(no_substitutions_mean), nrow = length(substituting_amino_acids),ncol = length(wtseq))
colnames(substitution_table) <- wt_amino_acids
rownames(substitution_table) <- substituting_amino_acids
# Fill table with mean values
for(i in 1:length(SingleSubsht)) {
  for(j in 1:nchar(wt_sequence)) {
    if(substr(SingleSubsht[i],j,j) != wtseq[j]) {
      substitution_table[substr(SingleSubsht[i],j,j),j] <- d4[d4$seq==SingleSubsht[i],"mean"]
    }
  }
}
# Rearrange substitution_table for heatmap
st <- data.frame(substitution_table)
library(tidyr)
st_gathered <- gather(st)
names(st_gathered) <- c("Position", "Fluorescence") 
# Keep only the position number without the WT residue
st_gathered$Position <- substring(st_gathered$Position, 2)
# Add the substituting AA and context and rearrange the DF
st_gathered$Substitution <- substituting_amino_acids
st_gathered$Context <- context
st_gathered_DM <- st_gathered[,c(1,3,2,4)]

#Create the data frame for all contexts

st_gathered_ALL <- rbind(st_gathered_WT,st_gathered_H199Y,st_gathered_T203Y,st_gathered_T203I,st_gathered_L207V,st_gathered_L207R,st_gathered_DM)

# Getting objects ready for the plot
Context <- factor(c("WT", "H199Y", "T203Y", "T203I", "L207V", "L207R","H199Y/T203Y"), levels = c("WT", "H199Y", "T203Y", "T203I", "L207V", "L207R", "H199Y/T203Y"))

Position <- factor(st_gathered_ALL$Position, levels = c("195", "196", "197", "198", "199", "200", "201", "202", "203", "204", "205", "206", "207", "208", "209", "210", "211", "212"))

Fluorescence <- st_gathered_ALL$Fluorescence

```


# Context vs fluorescence jitter plot

Plot comparing overall fluorescence of variants in different contexts

```{r}
#Fetch error bars by using the "script for sd pickup - context jitter plot" script in the same github folder
source("Fig_S6_sd.R")
st_gathered_ALL <- cbind(st_gathered_ALL, st_gathered_SD$SD) #SDs got 
names(st_gathered_ALL) <- c("Position", "Substitution", "Fluorescence", "Context", "SD") 
 WT <- st_gathered_ALL[st_gathered_ALL$Position=="195" & st_gathered_ALL$Substitution=="L" & st_gathered_ALL$Context == "WT", 3]
  #WT <- log2(WT) 
Fluorescence <- st_gathered_ALL$Fluorescence
SD <- st_gathered_ALL$SD


library(ggplot2)
manualcolors<-c('yellow','red2', 'cornflowerblue', 'orange', "springgreen4" , 
                'magenta', 'darkolivegreen4',  
                'indianred1', 'yellow3', 'darkblue', 
                'mediumorchid1','firebrick4',  'black', 'lightsalmon',
                'darkgray', 'darkorchid', 'seagreen1',
                'tan3')

p_context <- ggplot(data = st_gathered_ALL, aes(x=Context, y=Fluorescence, colour = factor(Position))) +
  geom_pointrange(aes(ymin = Fluorescence - SD, 
                      ymax = Fluorescence + SD), 
                    position=position_jitter(width=0.3),
                    linetype=1)+
  ylab("log2(Fluorescence)\n") +
  xlab("Context") +
  scale_x_discrete(limits=Context) +
  scale_y_continuous(limits = c(0,45000))+
  #coord_trans(ytrans = "log2") +
  geom_hline(yintercept=c(449.86,1013.2), linetype="dashed", color = c("black","black"), size=0.5) +
  scale_color_manual(values=manualcolors) +
  theme_minimal(base_size = 17) +
  labs(color="Substituted 
  position") +
  theme_classic()+
  scale_y_continuous(trans = 'log2') +
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.title = element_text(size = 20),
    axis.text = element_text(angle=90, size=20),
    legend.title = element_text(size=20),
    legend.text = element_text(size=18),
    plot.margin = unit(c(2, 0.5, 1, 0.5), "cm")) #top, right, bottom, left
p_context

```

# SDTS map (Single-Double-Triple-Substitution map)

```{r}
#colours <- c("steelblue3", "white", "indianred3")

WhiteRed <- colorRampPalette(c("white","indianred3")) (n = 2499)
Yellow <- colorRampPalette("lightyellow") (n = 1)
BlueWhite <- colorRampPalette(c("steelblue3","white")) (n = 2500)
color.palette  <- c(BlueWhite,Yellow,WhiteRed)

WT <- st_gathered_ALL[st_gathered_ALL$Position == "195" & st_gathered_ALL$Substitution == "L" & st_gathered_ALL$Context == "WT", 3]
WT <- log2(WT) 

col_breaks = c(seq(min(Fluorescence)-5,WT-0.02,length=2500),
               seq(WT-0.01,WT+0.01,length=1),
               seq(WT+0.02,max(Fluorescence)+5,length=2500))

#positions.yaxis = c("right", "left", "top"=FALSE, "bottom"=FALSE)

library(ggplot2)

context.heatmap <- ggplot(data = st_gathered_ALL, mapping = aes(x = factor(Context),
                                                         y = Substitution,
                                                         fill = log2(Fluorescence))) +
  geom_tile(color = "white") +
  #geom_rect() +
  xlab(label = "Sequence") +
  ylab(label = "Substituting residue") +
  facet_grid(~ Position, switch = "x", scales = "free_x", space = "free_x") +
  scale_y_discrete(position = "right", limits = c("Q", "N", "T", "S", "W", "Y", "F", "M", "L", "I", "V", "A", "P", "G", "C", "E", "D", "K", "H","R")) +
  scale_x_discrete(limits = c("WT", "H199Y", "T203Y", "T203I", "L207V", "L207R", "H199Y/T203Y")) +
  scale_fill_gradient2(low="blue", high="red", mid="yellow", 
                       midpoint = WT, limits = c(min(log2(Fluorescence)),max(log2(Fluorescence)))) +
  #scale_fill_gradientn(colours = color.palette, breaks = col_breaks) +
  theme(axis.text.x = element_text(angle = 90),legend.position="bottom")

context.heatmap 
```
# Best 5 perfoming peptides
```{r}
d5 <- as.vector(which(d$mean > 28000))
d_b5<- d[d5,]
d_b5 #best5
#d_b5 <- d_b5[,c(2,5:16)]
# seq5 <- d_b5$seq
# gather(d_b5, key=seq5)
#install.packages("reshape")
# library(reshape)
# melt(d_b5, id=seq5)
```


# Effect of H199Y and T203Y

Since the data contains site-saturation variants of both the WT, H199Y and T203Y single mutants and the double mutant, we can follow the intensity effect of H199Y and T203Y in a double mutant cycle and make robust estimates using EEE correlations. Firstly, data frames are genearted for the 4 mutations: WT->H199Y, H199Y->db., WT->T203Y and T203Y->db.

```{r}
di = which(d$w=="short" & d$d<=2)
pos = 2
ete = paste(substr(d[di,'seq'],1,pos-1),substr(d[di,'seq'],pos+1,nchar(d[di,'seq'])), sep="")
pos_aa = substr(d[di,'seq'],pos,pos)
v = rep(0,length(pos_aa))
v[which(pos_aa=="H")] = 1
v[which(pos_aa=="Y")] = 2
i = etee_match(ete, v)
i1 = di[i[,1]]
i2 = di[i[,2]]
dd1 = data.frame(seq1=d[i1,'seq'], seq2=d[i2,'seq'], F1=d[i1,'mean'], F2=d[i2,'mean'], li1=d[i1,'link'], li2=d[i2,'link'], d1=d[i1,'d'], d2=d[i2,'d'])

pos = 6
pos_aa = substr(d[di,'seq'],pos,pos)
ete = paste(substr(d[di,'seq'],1,pos-1),substr(d[di,'seq'],pos+1,nchar(d[di,'seq'])), sep="")
v = rep(0,length(pos_aa))
v[which(pos_aa=="T")] = 1
v[which(pos_aa=="Y")] = 2
i = etee_match(ete, v)
i1 = di[i[,1]]
i2 = di[i[,2]]
dd2 = data.frame(seq1=d[i1,'seq'], seq2=d[i2,'seq'], F1=d[i1,'mean'], F2=d[i2,'mean'], li1=d[i1,'link'], li2=d[i2,'link'], d1=d[i1,'d'], d2=d[i2,'d'])

# PLOT of Y199 given Y203 and Y203 given Y199
di = which(d$w=="short")
pos1 = 2
pos2 = 6
pos_aa = paste(substr(d[di,'seq'],pos1,pos1), substr(d[di,'seq'],pos2,pos2), sep="")
ete = paste(substr(d[di,'seq'],1,pos1-1),substr(d[di,'seq'],pos1+1,pos2-1),substr(d[di,'seq'],pos2+1,nchar(d[di,'seq'])), sep="")
v = rep(0,length(pos_aa))
v[which(pos_aa=="YT")] = 1
v[which(pos_aa=="YY")] = 2
i = etee_match(ete, v)
i1 = di[i[,1]]
i2 = di[i[,2]]
dd3 = data.frame(seq1=d[i1,'seq'], seq2=d[i2,'seq'], F1=d[i1,'mean'], F2=d[i2,'mean'], li1=d[i1,'link'], li2=d[i2,'link'], d1=d[i1,'d'], d2=d[i2,'d'])

v = rep(0,length(pos_aa))
v[which(pos_aa=="HY")] = 1
v[which(pos_aa=="YY")] = 2
i = etee_match(ete, v)
i1 = di[i[,1]]
i2 = di[i[,2]]
dd4 = data.frame(seq1=d[i1,'seq'], seq2=d[i2,'seq'], F1=d[i1,'mean'], F2=d[i2,'mean'], li1=d[i1,'link'], li2=d[i2,'link'], d1=d[i1,'d'], d2=d[i2,'d'])
```

### Quantification of a intensity enhancement factor using  positive linker

```{r}
fit1 = lm(I(F2) ~ I(F1) -1, dd1[which(dd1$li1=="GKGSKSG"),])
fit2 = lm(I(F2) ~ I(F1) -1, dd2[which(dd2$li1=="GKGSKSG"),])
fit3 = lm(I(F2) ~ I(F1) -1, dd3[which(dd3$li1=="GKGSKSG"),])
fit4 = lm(I(F2) ~ I(F1) -1, dd4[which(dd4$li1=="GKGSKSG"),])
print(sprintf("WT -> H199Y: %.1f;  WT -> T203Y: %.1f;  H199Y -> Db: %.1f;  T203Y -> Db: %.1f",coef(fit1),coef(fit2),coef(fit3),coef(fit4)))
print(sprintf("Products: WT -> H199Y -> Db: %.1f;  WT -> T203Y -> Db: %.1f",coef(fit1)*coef(fit3),coef(fit2)*coef(fit4)))
```


```{r}
#quartz(height=3, width=11)
#par(mfcol=c(1,4))
coll = seq(2,5)
plot(dd1$F1, dd1$F2, pch=20, xlab="ShortWT", ylab="ShortWT + H199Y")
abline(0,1, lty=2)
abline(0, coef(fit1))
points(dd1$F1, dd1$F2, pch=20, cex=.5, col=coll[dd1$li1])
legend("bottomright",c(levels(dd1$li1),"fit","slope=1"), pch=c(20,20,20,20,NA,NA), lty=c(NA,NA,NA,NA,1,2), col=c(coll,1,1), bg="white")

plot(dd2$F1, dd2$F2, pch=20, xlab="ShortWT", ylab="ShortWT + T203Y")
abline(0,1, lty=2)
abline(0, coef(fit2))
points(dd2$F1, dd2$F2, pch=20, cex=.5, col=coll[dd2$li1])
legend("bottomright",c(levels(dd2$li1),"fit","slope=1"), pch=c(20,20,20,20,NA,NA), lty=c(NA,NA,NA,NA,1,2), col=c(coll,1,1), bg="white")

plot(dd3$F1, dd3$F2, pch=20, xlab="ShortWT + H199Y", ylab="ShortWT + H199Y + T203Y")
abline(0,1, lty=2)
abline(0, coef(fit3))
points(dd3$F1, dd3$F2, pch=20, cex=.5, col=coll[dd3$li1])
legend("bottomright",c(levels(dd3$li1),"fit","slope=1"), pch=c(20,20,20,20,NA,NA), lty=c(NA,NA,NA,NA,1,2), col=c(coll,1,1), bg="white")

plot(dd4$F1, dd4$F2, pch=20, xlab="ShortWT + T203Y", ylab="ShortWT + H199Y + T203Y")
abline(0,1, lty=2)
abline(0, coef(fit4))
points(dd4$F1, dd4$F2, pch=20, cex=.5, col=coll[dd4$li1])
legend("bottomright",c(levels(dd4$li1),"fit","slope=1"), pch=c(20,20,20,20,NA,NA), lty=c(NA,NA,NA,NA,1,2), col=c(coll,1,1), bg="white")

#quartz.save("short_H199Y_T203Y.png",type="png")
```
```{r}
######################################################
### Long H199Y and T203Y
######################################################
di = which(d$w=="long" & d$d<=2)
pos = 5
ete = paste(substr(d[di,'seq'],1,pos-1),substr(d[di,'seq'],pos+1,nchar(d[di,'seq'])), sep="")
pos_aa = substr(d[di,'seq'],pos,pos)
v = rep(0,length(pos_aa))
v[which(pos_aa=="H")] = 1
v[which(pos_aa=="Y")] = 2
i = etee_match(ete, v)
i1 = di[i[,1]]
i2 = di[i[,2]]
dd1 = data.frame(seq1=d[i1,'seq'], seq2=d[i2,'seq'], F1=d[i1,'mean'], F2=d[i2,'mean'], li1=d[i1,'link'], li2=d[i2,'link'], d1=d[i1,'d'], d2=d[i2,'d'])

pos = 9
pos_aa = substr(d[di,'seq'],pos,pos)
ete = paste(substr(d[di,'seq'],1,pos-1),substr(d[di,'seq'],pos+1,nchar(d[di,'seq'])), sep="")
v = rep(0,length(pos_aa))
v[which(pos_aa=="T")] = 1
v[which(pos_aa=="Y")] = 2
i = etee_match(ete, v)
i1 = di[i[,1]]
i2 = di[i[,2]]
dd2 = data.frame(seq1=d[i1,'seq'], seq2=d[i2,'seq'], F1=d[i1,'mean'], F2=d[i2,'mean'], li1=d[i1,'link'], li2=d[i2,'link'], d1=d[i1,'d'], d2=d[i2,'d'])

# PLOT of Y199 given Y203 and Y203 given Y199
di = which(d$w=="long")
pos1 = 5
pos2 = 9
pos_aa = paste(substr(d[di,'seq'],pos1,pos1), substr(d[di,'seq'],pos2,pos2), sep="")
ete = paste(substr(d[di,'seq'],1,pos1-1),substr(d[di,'seq'],pos1+1,pos2-1),substr(d[di,'seq'],pos2+1,nchar(d[di,'seq'])), sep="")
v = rep(0,length(pos_aa))
v[which(pos_aa=="YT")] = 1
v[which(pos_aa=="YY")] = 2
i = etee_match(ete, v)
i1 = di[i[,1]]
i2 = di[i[,2]]
dd3 = data.frame(seq1=d[i1,'seq'], seq2=d[i2,'seq'], F1=d[i1,'mean'], F2=d[i2,'mean'], li1=d[i1,'link'], li2=d[i2,'link'], d1=d[i1,'d'], d2=d[i2,'d'])

v = rep(0,length(pos_aa))
v[which(pos_aa=="HY")] = 1
v[which(pos_aa=="YY")] = 2
i = etee_match(ete, v)
i1 = di[i[,1]]
i2 = di[i[,2]]
dd4 = data.frame(seq1=d[i1,'seq'], seq2=d[i2,'seq'], F1=d[i1,'mean'], F2=d[i2,'mean'], li1=d[i1,'link'], li2=d[i2,'link'], d1=d[i1,'d'], d2=d[i2,'d'])
```

```{r}
# Quantification using ArrayIIIa, a background of 350 and positive linker
fit1 = lm(I(F2) ~ I(F1) -1, dd1[which(dd1$li1=="none"),])
fit2 = lm(I(F2) ~ I(F1) -1, dd2[which(dd2$li1=="none"),])
fit3 = lm(I(F2) ~ I(F1) -1, dd3[which(dd3$li1=="none"),])
fit4 = lm(I(F2) ~ I(F1) -1, dd4[which(dd4$li1=="none"),])
print(sprintf("WT -> H199Y: %.1f;  WT -> T203Y: %.1f;  H199Y -> Db: %.1f;  T203Y -> Db: %.1f",coef(fit1),coef(fit2),coef(fit3),coef(fit4)))
print(sprintf("WT -> H199Y -> Db: %.1f;  WT -> T203Y -> Db: %.1f",coef(fit1)*coef(fit3),coef(fit2)*coef(fit4)))
```

```{r}
#quartz(height=3, width=11)
#par(mfcol=c(1,4))
coll = seq(2,3)
plot(dd1$F1, dd1$F2, pch=20, xlab="LongWT", ylab="LongWT + H199Y")
abline(0,1, lty=2)
abline(0, coef(fit1))
points(dd1$F1, dd1$F2, pch=20, cex=.5, col=coll[dd1$li1])
legend("bottomright",c(levels(dd1$li1),"fit","slope=1"), pch=c(20,20,NA,NA), lty=c(NA,NA,1,2), col=c(coll,1,1), bg="white")


plot(dd2$F1, dd2$F2, pch=20, xlab="LongWT", ylab="LongWT + T203Y")
abline(0,1, lty=2)
abline(0, coef(fit2))
points(dd2$F1, dd2$F2, pch=20, cex=.5, col=coll[dd2$li1])
legend("bottomright",c(levels(dd2$li1),"fit","slope=1"), pch=c(20,20,NA,NA), lty=c(NA,NA,1,2), col=c(coll,1,1), bg="white")

plot(dd3$F1, dd3$F2, pch=20, xlab="LongWT + H199Y", ylab="LongWT + H199Y + T203Y")
abline(0,1, lty=2)
abline(0, coef(fit3))
points(dd3$F1, dd3$F2, pch=20, cex=.5, col=coll[dd3$li1])
legend("bottomright",c(levels(dd3$li1),"fit","slope=1"), pch=c(20,20,NA,NA), lty=c(NA,NA,1,2), col=c(coll,1,1), bg="white")

plot(dd4$F1, dd4$F2, pch=20, xlab="LongWT + T203Y", ylab="LongWT + H199Y + T203Y")
abline(0,1, lty=2)
abline(0, coef(fit4))
points(dd4$F1, dd4$F2, pch=20, cex=.5, col=coll[dd4$li1])
legend("bottomright",c(levels(dd4$li1),"fit","slope=1"), pch=c(20,20,NA,NA), lty=c(NA,NA,1,2), col=c(coll,1,1), bg="white")

#quartz.save("long_H199Y_T203Y.png",type="png")
```

# Experimental

```{r}
#Plot array data for selected variants
dexp <- d[d$seq %in% c("LPDNHYLSTQTVRSKDPN","LPDNHYLSTQTVLSKDPN","LPDNYYLSTQTVLSKDPN","LPDNHYLSYQTVLSKDPN","LPDNYYLSYQTVLSKDPN"),]

  dplot <- dexp[,-c(1,3,4,17,18,19,20,21,22,23,24,25,26,27,28)]
  
  library(reshape2)
  dplot_m <- melt(dplot)
  variant <- factor(dplot_m$seq, 
                    levels = c("LPDNHYLSTQTVRSKDPN","LPDNHYLSTQTVLSKDPN","LPDNYYLSTQTVLSKDPN","LPDNHYLSYQTVLSKDPN","LPDNYYLSYQTVLSKDPN"),
                    labels = c("L207R", "WT", "H199Y","T203Y", "H199Y/T203Y"))
  dplot_m$variant <- variant
  value_n <- dplot_m$value / 742 #normalize all to mean WT
  dplot_m$value <- value_n # plot the relative (normalized) data
  
  #tiff("exp-array.tiff", units="in", width=12, height=15, res=500) 
    library(ggplot2)
  library(ggbeeswarm)
  ggplot(data=dplot_m, aes(x=variant,y=value, colour=variant)) +
    geom_boxplot(lwd=2) +
    geom_jitter() +
    scale_x_discrete(limits = c("L207R", "WT", "H199Y","T203Y", "H199Y/T203Y")) +
    scale_y_continuous(breaks = c(1,5,10,15,20,25,30)) +
    ylab("Variant/WT Array fluorescence\n") +
    xlab("Variant") +
    # geom_hline(yintercept=log(mean(FLAG_all)), linetype="dashed", color = "black", size=0.5)
    theme_classic() +
    theme(legend.position = "none",
          # legend.text=element_text(size=20),
          # legend.title=element_text(size=18), 
          axis.text.y=element_text(size=20, colour = "black"),
          axis.title=element_text(size=22, colour = "black"), 
          axis.text.x=element_text(size=20, angle = 90, colour = "black"),
          panel.border = element_rect(colour = "black", fill=NA, size=2)) +
    scale_color_manual(values=c("gray50", "steelblue2", "springgreen3","goldenrod1","darkorange2"))
  #dev.off()
```


# Look at global RSD

```{r}
# short-gk7
short_gk7 <- d[d$w=="short"&d$l_len=="7"&d$l_chg=="2",2:4]
short_gk7$rsd <- short_gk7$sd * 100 / short_gk7$mean 
print(median(short_gk7$rsd, na.rm = TRUE))
```

